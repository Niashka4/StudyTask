#pragma once
using namespace std;

int** create(int n, int m) {  //  Функция создание двумерного динамического массива
	int** a = new int* [n];  //  Выделяем память для массива
	for (int i = 0; i < n; i++)  //  Запускаем цикл по его рядам 
		a[i] = new int[m];  //  Создаем столбцы
	for (int i = 0; i < n; i++)  // Запускаем цикл по рядам массива  
		for (int j = 0; j < m; j++) {  //  Запускаем цикл по столбцам массива
			cout << "a[" << i << "][" << j << "] = ";  //  Выводим текст
			cin >> a[i][j];  //  Вводим значения элементов
		}
	return a;  //  Возвращаем массив
}

void print(int** a, int n, int m) {  //  Функция для вывода массива
	for (int i = 0; i < n; i++, cout << endl)  //  Запускаем цикл по рядам массива 
		for (int j = 0; j < n; j++)  //  Запускаем цикл по столбцам массива
			cout << a[i][j] << " ";  //  Выводим текст
	cout << endl;  //  Отступ
}

int* create_x(int m) {  //  Функция создание одномерного массива
	int* x = new int[m];  //  Выделяем память
	cout << endl << "Enter X: \n";  //  Выводим текст
	for (int i = 0; i < m; i++)  //  Запускаем цикл по элементам массива
		cin >> x[i];  //  Вводим их значение
	return x;  //  Выводим массив
}

void swap4(int** a, int n, int m, int* x) {  //  Функция для замены рядов массива на другой массив 
	for (int i = 0; i < n; i++)  //  Запускаем цикл по рядам массива
		for (int j = 0; j < m; j++)  //  Запускаем цикл по столбцам массива
			if (i % 2 == 0) a[i][j] = x[j];  //  Если ряд четный, то меняем его значение 
}

int max9(int** a, int n, int m) {  //  Функция поиска столбца с максимальным элементом
	int max = a[0][0], j_max = 0;  //  Задаем начальные значения 
	for (int i = 0; i < n; i++)  //  Запускаем цикл по рядам массива
		for (int j = 0; j < m; j++)  //  Запускаем цикл по столбцам массива
			if (a[i][j] >= max) {  //  Находим максимальный элемент
				max = a[i][j]; j_max = j;  // Переприсваиваем значения 
			}
	return j_max;  //  Возвращаем стоблец с максимальным элементом
}

int min9(int** a, int n, int m) {  //  Функция поиска столбца с минимальным элементом
	int min = a[0][0], j_min = 0;  //  Задаем начальные значения 
	for (int i = 0; i < n; i++)  //  Запускаем цикл по рядам массива
		for (int j = 0; j < m; j++)  //  Запускаем цикл по столбцам массива
			if (a[i][j] < min) {  //  Находим минимальный элемент
				min = a[i][j]; j_min = j;  //  Переприсваиваем значения 
			}
	return j_min;  //  Возвращаем стоблец с минимальным элементом
}

void swap9(int** a, int n, int m, int j_min, int j_max) {  //  Функция замены двух столбцов
	int d = 0;  //  Создаём вспомогательную переменную
	for (int i = 0; i < n; i++) {  //  Запускаем цикл по рядам массива
		d = a[i][j_min]; a[i][j_min] = a[i][j_max]; a[i][j_max] = d;  //  Делаем замены
	}
}

void swap14(int** a, int n, int m) {  //  Функция замены двух необходимых элементов

	int flag = 0, d = 0;   //  Создаём вспомогательные переменные

	int max = a[0][1], i_max = 0, j_max = 1;  //  Задаем начальные значения 
	for (int i = 0; i < n; i++)   //  Запускаем цикл по рядам массива
		for (int j = i + 1; j <= m; j++)  //  Запускаем цикл по столбцам массива выше главной диагонали
			if ((a[i][j] > max) && (a[i][j] % 2 != 0)) {  //  Находим максимальный нечетный элемент
				max = a[i][j]; i_max = i; j_max = j;  //  Переприсваиваем значения 
			}
	for (int i = 0; i < n; i++)  //  Запускаем цикл по рядам массива на главной диагонали
		for (int j = n - 1 - i; j < m; j++)  //  Запускаем цикл по столбцам массива
			if ((a[i][j] > max) && (a[i][j] % 2 != 0)) {  //  Находим максимальный нечетный элемент
				max = a[i][j]; i_max = i; j_max = j;  //  Переприсваиваем значения 
			}
	if (max % 2 == 0) { cout << "Net pervogo nechetnogo elementa"; flag += 1; }  //  Если максимальный элемент четный, то выводим текст, нужного элемента нет

	int min = a[1][0], i_min = 1, j_min = 0;  //  Задаем начальные значения 
	for (int i = 0; i < n; i++)  //  Запускаем цикл по рядам массива ниже главной диагонали
		for (int j = 0; j < i + 1; j++)  //  Запускаем цикл по столбцам массива
			if ((a[i][j] < min) && (a[i][j] % 2 == 0)) {  //  Находим минимальный четный элемент
				min = a[i][j]; i_min = i; j_min = j;  //  Переприсваиваем значения 
			}
	if (min % 2 != 0) { cout << "Net pervogo chetnogo elementa"; flag += 1; }  //  Если минимальный элемент нечетный, то выводим текст, нужного элемента нет
	if (flag == 0) {  //  Если все элементы найдены, то производим замену
		d = a[i_min][j_min]; a[i_min][j_min] = a[i_max][j_max]; a[i_max][j_max] = d;  //  Элементы меняются местами
	}
}

int** create20(int n) {  //  Функция создания массива со "змейкой"
	int** a = new int* [n];  //  Выделяем память для массива
	for (int i = 0; i < n; i++)  //  Запускаем цикл по его рядам 
		a[i] = new int[n];  //  Создаем столбцы
	int p = 0;  //  Создаем переменную
	for (int j = n - 1; j >= 0; j--) {  //  Запускаем цикл по столбцам массива с последнего до первого
		if (((j % 2) != (n % 2))) {  //  Если четность этого столбца не совпадает с четностью количества всех столбцов, то...
			for (int i = 0; i < n; i++) {  //  Запускаем цикл по рядам массива
				a[i][j] = p;  //  Присваиваем значение элементу массива
				p++;  //  Увеличиваем значение p на 1
			}
		}
		else {  //  Иначе...
			for (int i = n - 1; i >= 0; i--) {  //  Запускаем цикл по рядам массива от последнего до первого
				a[i][j] = p;  //  Присваиваем значение элементу массива
				p++;  //  Увеличиваем значение p на 1
			}
		}
	}
	return a;  //  Возвращаем массив
}
