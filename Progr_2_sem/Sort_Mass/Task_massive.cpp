#include <iostream>  //  Подключаем нужные библиотеки
#include <fstream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

void bucket_sort(int n, vector<int> &ad) {  //  Функция для блочной сортировки 
	int maxi = *max_element(ad.begin(), ad.end());  //  Находим максимальный элемент
	int mini = *min_element(ad.begin(), ad.end());  //  Находим минимальный элемент
	int p = n / 3;  //  Находим колличество корзин
	int m = (maxi - mini) / p;  //  Находим диапазон значений в корзине
	vector<vector<int>> bucket(p);  //  Создаём вектор векторов корзин
	for (int i = 0; i < n; i++) {  //  Прохоимся по всем элементам вектора
		int k = (ad[i] - mini) / m;  //  Определяем номер корзины, в которую положим элемент
		if (k == p) bucket[p - 1].push_back(ad[i]);  //  Если номер корзины равен их количеству, то определяем элемент в последнюю корзину
		else bucket[k].push_back(ad[i]);  //  Иначе кладем элемент в свою корзину
	}
	ad.clear();  //  Очищаем изначальный вектор
	for (int h = 0; h < p; h++) {  //  Проходимся по всем корзинам
		sort(bucket[h].begin(), bucket[h].end(), greater<int>());  //  Сортируем их
	}
	for (int h = p - 1; h >= 0; h--)  //  Проходимся по всем корзинам
		for (vector<int>::iterator it = bucket[h].begin(); it != bucket[h].end(); it++) {  //  Объединяем элементы всех корзин в один вектор
			ad.push_back(*it);  //  Добавляем этот элемент
		}
}

void gnom(vector<int>& x) {  //  Функция гномьей сортировки 
	int i = 1;  //  Начинаем с первого элемента
	while (i < x.size()) {  //  До тех пор пока мы не вышли за границы вектора...
		if (i == 0) i++;  //  Если мы дошли до нулевого элемента, делаем шаг вперёд
		else if (x[i - 1] >= x[i]) i++;  //  Если, элемент спереди больше чем предыдущий, то всё верно, и мы делаем шаг вперёд
		else {  //  Иначе
			swap(x[i - 1], x[i]);  //  Меняем элементы местами
			i--;  //  Делаем шаг назад
		}
	}
}

void vstavka_sort(vector<int>& x) {  //  Функция сортировки вставками
		for (int i = 1; i < x.size(); i++)  //  Проходимся по всем элементам вектора
			for (int j = i; j > 0 && x[j - 1] > x[j]; j--)  // Если элемент не на своём месте, несём его назад
				swap(x[j - 1], x[j]);  //  Меняем неправильно стоящие элементы местами
}


int main() {
	ifstream in("Mass1.txt");  //  Подключаем файл
	ofstream out("Out.txt");  //  Выводим нашу матрицу в этот файл
	int el, n, numb = 0, i = 0;  //  Создаём необходимые переменные
	cout << "Enter size of massive: "; cin >> n;  //  Вводим размер матрицы
	cout << "Enter number of task: "; cin >> numb;  //  Вводим номер задания
	if (numb == 1) {  //  Если выбран первый номер...
		vector<int> arr;  //  Создаём вектор для сортировки
		while (in.peek() != EOF) {  //  Пока мы не дойдём до конца файла
			in >> el;  //  Получаем элемент матрицы
			i++;  //  Увеличиваем номер элемента
			arr.push_back(el);  //  Добавляем этот элемент в вектор
			if (i == n) {  //  Если дошли до конца строки...
				bucket_sort(n, arr);  //  Сортируем блоками вектор
				for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++) out << *it << " ";  //  Выводим в файл получившуюся строку
				out << endl;  //  Делаем отступ на новую строку
				arr.clear();  //  Очищаем вектор
				i = 0;  //  Обнуляем номер элемента
			}
		}
	}
	if (numb == 2) {  //  Если выбрано задание 2...
		int nch = 0;  //  Переменная для номера строки
		vector<int> arr;  //  Создаём вектор для сортировки
		while (in.peek() != EOF) {  //  Пока мы не дойдём до конца файла
			in >> el;  //  Получаем элемент матрицы
			i++;  //  Увеличиваем номер элемента
			arr.push_back(el);  //  Добавляем этот элемент в вектор
			if ((i == n) && (nch % 2 != 0)) {  //  Если дошли до конца строки и она нечетная...
				gnom(arr);  //  Сортируем гномьей сортировкой вектор
				for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++) out << *it << " ";  //  Выводим в файл получившуюся строку
				out << endl;  //  Делаем отступ на новую строку
				arr.clear();  //  Очищаем вектор
				i = 0;  //  Обнуляем номер элемента
				nch++;  //  Увеличиваем номер строки
			}
			if ((i == n) && (nch % 2 == 0)) {  //  Если строка четная и мы дошли до ее конца, то...
				for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++) out << *it << " ";  //  Выводим в файл строку без изменений
				out << endl;  //  Делаем отступ на новую строку
				arr.clear();  //  Очищаем вектор
				i = 0;  //  Обнуляем номер элемента
				nch++;  //  Увеличиваем номер строки
			}
		}
	}
	if (numb == 3) {  //  Если выбрано задание 3...
		int** a = new int* [n];  //  Создаем двумерный массив
		for (int i = 0; i < n; i++) {  //  Проходимся по всем строкам
			a[i] = new int[n];  //  Создаём столбцы
			for (int j = 0; j < n; j++)  //  Проходимся по всем столбцам и...
				in >> a[i][j];  //  Заполяем столбец элементами из файла
		}
		for (int k = 1; k <= 2 * n - 2; k++) {  //  Проходимся по всем диагоналям, параллельным побочной
			vector<int> help;  //  Создаём вектор для сортировки
			for (int i = 0; i < n; i++) {  //  Проходимся по всем строкам
				if ((k - i < n) && (k - i >= 0))  //  Условие нахождения элемента на конкретной диагонали
					help.push_back(a[i][k - i]);  //  Добавляем его в вектор
			}
			vstavka_sort(help);  //  Сортируем вектор вставками
			int L = 0;  //  Создаём вспомогательную переменную
			for (int i = 0; i < n; i++) {  //  Идём по всем строкам
				if ((k - i < n) && (k - i >= 0)) {  //  Если элемент находится на конкретной диагонали
					a[i][k - i] = help[L];  //  Заменяем его на новый отсортированный элемент
					L++;  //  Увеличиваем переменную
				}
			}
			help.clear();  //  Очищаем вектор
		}
		for (int i = 0; i < n; i++) {  //  Идём по всем строкам...
			for (int j = 0; j < n; j++)  //  и столбцам
				out << setw(5) << a[i][j];  //  Выводим в файл новую матрицу
			out << '\n';  //  Переходим на новую строку
		}
	}
	return 0;
}



