#include <iostream>  //  Подключаем нужные библиотеки

using namespace std;

struct list {  //  Структура списка
	int inf;  //  Значение ячейки
	list* next;  //  Ссылка на следующий элемент
	list* prev;  //  Ссылка на предыдущий элемент
};

void push(list*& h, list*& t, int x) {  //  Функция добавления элемента в конец списка
	list* r = new list;  //  Создаём новую ячейку
	r->inf = x;  //  Её значение 
	r->next = NULL;  //  Следующий элемент пуст
	if (!h && !t) {  //  Если список пуст, то...
 		r->prev = NULL;  //  Предыдущая ячейка пуста
		h = r;  //  Значение головы
	}
	else {  //  Иначе
		t->next = r;  //  Следующее после головы - новый элемент  
		r->prev = t;  //  Предыдущее для нового элемента - хвост
	}
	t = r;  //  Хвост теперь - это новый элемент
}

void print(list* h, list* t) {  //  Функция вывода списка
	list* p = h;  //  Создаём указатель на голову
	while (p) {  //  Пока указатель не пуст
		cout << p->inf << " ";  //  Выводим значение указателя
		p = p->next;  //  Двигаем указатель дальше
	}
}

void insert_after(list*& h, list*& t, list* r, int y) {  //  Функция вставки элемента после другого
	list* p = new list;  //  Создаём новый элемент
	p->inf = y;  //  Его значение y
	if (r == t) {  //  Если вставляем в конец
		p->next = NULL;  //  Следующий элемент пуст
		p->prev = r;  //  Предыдущий - это элемент после которого вставляли
		r->next = p;  //  Следующий для элемента после которого вставляли - новый элемент
		t = p;  //  Хвост - новый элемент
	}
	else {  //  Иначе
		r->next->prev = p;  //  Предыдущий для следующего после элемента r - новый элемент
		p->next = r->next;  //  Следующий для нового - элемент после r
		p->prev = r;  //  Предыдущий для нового - r
		r->next = p;  //  Следующий для r - новый элемент
	}
}

void result(list*& h, list*& t, int posl, int max) {  //  Функция для выполнения задания
	list* p = h;  //  Создаём указатель на голову
	while (p) {  //  Идём по всем элементам списка
		if (p->inf == posl) { insert_after(h, t, p, max); p = p->next; }  //  Если значение ячейки равно последнему элементу, вставляем максимальный элемент после него и двигаем указатель
		p = p->next;  //  Двигаем указатель дальше
	}
}

int main() { 
	setlocale(LC_ALL, "Russian");  //  Подключаем русский язык
	int n, el = 0, posl = 0, max = 0;  //  Создаём необходимые переменные
	list* head = NULL;  //  Инициализируем голову
	list* tail = NULL;  //  Инициализируем хвост
	cout << "Введите количество чисел: "; cin >> n;  //  Вводим количество чисел
	for (int i = 0; i < n; i++) {  //  Проходим циклом от 0 до n
		cin >> el;  //  Вводим число
		if (i == 0) max = el;  //  Если элемент первый, то пока он максимальный
		if (i == n - 1) posl = el;  //  Если элемент последний, то запоминаем его значение
		if (el > max) max = el;  //  Если элемент больше максимального, то он теперь максимальный
		push(head, tail, el);  //  Добавляем в список элемент
	}
	result(head, tail, posl, max);  //  Изменяем список по условию
	print(head, tail);  //  Печатаем список
	return 0;
}



