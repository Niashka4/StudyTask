#include <iostream> 

using namespace std;

struct queue {  //  Структура очереди
	int Inf;  //  Значение ячейки
	queue* next;  //  Ссылка на следующий элемент
};

void push(queue*& h, queue*& t, int x) {  //  Функция вставки в конец очереди нового элемента
	queue* r = new queue;  //  Создаём новую очередь
	r->Inf = x;  //  Добавляем новый элемент
	r->next = NULL;  //  Он является последним
	if (!h && !t) {  //  Если очередь пуста
		h = t = r;  //  Новый элемент является и головой и хвостом
	}
	else {  //  Иначе
		t->next = r;  //  Новый элемент стоит после хвоста
		t = r;  //  И является последним
	}
}

int pop(queue*& h, queue*& t) {  //  Функция удаления из начала очереди элемента
	queue* r = h;  //  Создаём ссылку на голову
	int i = h->Inf;  //  Сохраняем значение головы
	h = h->next;  //  Новая голова - это новый элемент
	if (!h) t = NULL;  //  Если это последний элемент, то хвост - пуст
	delete r;  //  Удаляем первый элемент
	return i;  //  Возвращаем удаленный элемент
}

void reverse(queue*& h, queue*& t) {  //  Функция обращения очереди
	queue* head1 = NULL;  //  Голова и хвост пусты
	queue* tail1 = NULL;
	while (h)  //  Пока очередь не пуста
		push(head1, tail1, pop(h, t));  //  Заполняем очередь
	h = head1;  //  Новая голова
	t = tail1;  //  Новый хвост
}

queue* result(queue*& h, queue*& t, int max) {  //  Функция создания результирующей очереди
	queue* res = NULL;  //  Инициализируем новую очередь
	queue* t1 = NULL;
	queue* h1 = NULL;  //  И еще одну вспомогательную
	queue* t2 = NULL;
	int fl = 0;  //  Переменная-флаг о том, что мы дошли о первого максимального
	while (h) {  //  Пока не дойдём до конца старой очереди
		int x = pop(h, t);  //  Получаем её элемент
		if (x == max && fl == 0) {  //  Если он максимальный и первый максимальный
			push(res, t1, x);  //  Вставляем этот элемент в результирующую очередь
			fl = 1;  //  Мы дошли о него
		}
		else if (fl == 0) push(h1, t2, x);  //  Если мы еще не дошли до первого максимального, то вставляем этот элемент во вспомогательную очередь
		else push(res, t1, x);  //  Иначе, перемещаем всё оставшееся в результирующую очередь
	}
	while (h1) {  //  Пока не дойдём до конца вспомогательной очереди
		int x = pop(h1, t2);  //  Получаем элемент
		push(res, t1, x);  //  Переносим его в результирующую очередь
	}
	t = t1;  //  Переобозначаем хвост
	return res;  //  Возвращаем результирующую очередь
}

int main() {
	setlocale(LC_ALL, "Russian");  //  Подключаем русский язык
	int n;  //  Переменная количества чисел
	cout << "Введите количество чисел:" << endl;  //  Выводим текст 
	cin >> n;  //  Вводим их количество
	queue* head = NULL; queue* tail = NULL;  //  Инициализируем очередь
	int x, max = 0;  //  Создаём необходимые переменные
	for (int i = 0; i < n; i++) {  //  Идем по всем номерам чисел
		cin >> x;  //  Вводим число
		if (i == 0) {  //  Если это первое число, то...
			max = x;  //  Оно пока что максимальное
		}
		if (x > max) max = x;  //  Если число больше максимального, то теперь оно максимальное
		push(head, tail, x);  //  Вставляем число в оередь
	}
	reverse(head, tail);  //  Переворачиваем очередь
	queue* res = result(head, tail, max);  //  Создаём новую очередь по условию  
	while (res)  //  Пока мы не дойдем до конца очереди
		cout << pop(res, tail) << " ";  //  Выводим элемент очереди
	cout << endl;  //  Пропускаем строку
	return 0;
}
